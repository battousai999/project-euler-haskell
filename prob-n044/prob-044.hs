-- Pentagonal numbers are generated by the formula, P_n=n(3n−1)/2. The first ten pentagonal numbers are:

-- 1, 5, 12, 22, 35, 51, 70, 92, 117, 145, ...

-- It can be seen that P_4 + P_7 = 22 + 70 = 92 = P_8. However, their difference, 70 − 22 = 48, is not pentagonal.

-- Find the pair of pentagonal numbers, P_j and P_k, for which their sum and difference are pentagonal and 
-- D = |P_k − P_j| is minimised; what is the value of D?

import Data.List (find, sortBy)
import Data.Maybe (fromMaybe)
import qualified Data.Set as Set

limit :: Integer
limit = 30000

pentagonalNumber :: Integer -> Integer
pentagonalNumber num = (num * (3 * num - 1)) `div` 2

pentagonalNumbers :: [Integer]
pentagonalNumbers = map pentagonalNumber [1..limit]

pentagonalSet :: Set.Set Integer
pentagonalSet = Set.fromDistinctAscList pentagonalNumbers

isPentagonalNumber :: Integer -> Bool
isPentagonalNumber num = Set.member num pentagonalSet

candidates :: Integer -> Integer -> [Integer]
candidates limit num =
    let p_k = pentagonalNumber num
        isSpecial x = 
            let p_j = pentagonalNumber x
            in  isPentagonalNumber (p_k + p_j) && isPentagonalNumber (p_k - p_j)
        isUnderLimit x = p_k - pentagonalNumber x < limit
        maybeLowIndex = if limit == 1 then Just 1 else find (not . isUnderLimit) [(num - 1), (num - 2)..1]
        lowIndex = fromMaybe 1 maybeLowIndex
    in  filter isSpecial [lowIndex..(num - 1)]

main = do
    let (firstNum, firstCandidate:_) = head $ filter (not . null . snd) $ map (\x -> (x, sortBy (flip compare) (candidates 1 x))) [1..limit]
        
    print (firstNum, firstCandidate)







-- pentagonalNumber :: Integer -> Integer
-- pentagonalNumber num = (num * (3 * num - 1)) `div` 2

-- pentagonalNumbers :: [Integer]
-- pentagonalNumbers = map pentagonalNumber [1..1000000]

-- isPentagonalNumber2 :: Integer -> Bool
-- isPentagonalNumber2 num 
--     | num <= 0 = False
--     | otherwise =
--         let result = find (>= num) pentagonalNumbers
--         in  case result of
--                 Nothing -> False
--                 Just x  -> x == num

-- (^!) :: Num a => a -> Int -> a
-- (^!) x n = x^n

-- squareRoot :: Integer -> Integer
-- squareRoot 0 = 0
-- squareRoot 1 = 1
-- squareRoot n =
--     let twopows = iterate (^!2) 2
--         (lowerRoot, lowerN) = last $ takeWhile ((n>=) . snd) $ zip (1:twopows) twopows
--         newtonStep x = div (x + div n x) 2
--         iters = iterate newtonStep (squareRoot (div n lowerN) * lowerRoot)
--         isRoot r = r^!2 <= n && n < (r+1)^!2
--     in  head $ dropWhile (not . isRoot) iters                

-- isPentagonalNumber :: Integer -> Bool
-- isPentagonalNumber num
--     | num <= 0 = False
--     | otherwise =
--         let c = (squareRoot (num * 24 + 1) + 1) `div` 6
--         in  pentagonalNumber c == num                 


-- -- using this is probably going to take too long...
-- candidates :: Integer -> [Integer]
-- candidates num =
--     let p_k = pentagonalNumber num
--         isSpecial x = 
--             let p_j = pentagonalNumber x
--             in  isPentagonalNumber2 (p_k + p_j) && isPentagonalNumber2 (p_k - p_j)
--     in  filter isSpecial [1..(num - 1)]
            
-- main = do
--     print $ candidates 10000
