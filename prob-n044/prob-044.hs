-- Pentagonal numbers are generated by the formula, P_n=n(3n−1)/2. The first ten pentagonal numbers are:

-- 1, 5, 12, 22, 35, 51, 70, 92, 117, 145, ...

-- It can be seen that P_4 + P_7 = 22 + 70 = 92 = P_8. However, their difference, 70 − 22 = 48, is not pentagonal.

-- Find the pair of pentagonal numbers, P_j and P_k, for which their sum and difference are pentagonal and 
-- D = |P_k − P_j| is minimised; what is the value of D?

import Data.List (find, sortBy)
import Data.Maybe (fromMaybe)
import qualified Data.Set as Set

-- Cap the list of pentagonal numbers so that we can create a Set from the 
-- list (to make isPentagonalNumber fast).  Note that using a Set for this
-- is not particularly memory-friendly.
listSize :: Integer
listSize = 10000000

pentagonalNumber :: Integer -> Integer
pentagonalNumber num = (num * (3 * num - 1)) `div` 2

pentagonalNumbers :: [Integer]
pentagonalNumbers = map pentagonalNumber [1..listSize]

pentagonalSet :: Set.Set Integer
pentagonalSet = Set.fromDistinctAscList pentagonalNumbers

isPentagonalNumber :: Integer -> Bool
isPentagonalNumber num = Set.member num pentagonalSet

candidates :: Integer -> Integer -> [Integer]
candidates limit num =
    let p_k = pentagonalNumber num
        isSpecial x = 
            let p_j = pentagonalNumber x
            in  isPentagonalNumber (p_k + p_j) && isPentagonalNumber (p_k - p_j)
        -- Use the 'limit' to determine a 'lowIndex' that skips a lot of work (don't
        -- call isSpecial on values whose pentagonal difference with 'num' would be
        -- larger than 'limit' 
        isUnderLimit x = p_k - pentagonalNumber x < limit
        maybeLowIndex = if limit == 1 then Just 1 else find (not . isUnderLimit) [(num - 1), (num - 2)..1]
        lowIndex = fromMaybe 1 maybeLowIndex
    in  filter isSpecial [lowIndex..(num - 1)]

calcValue :: (Integer, Integer) -> Integer -> Maybe (Integer, Integer)
calcValue (x, y) limit =
    let result = find (not . null . snd) $ map (\x -> (x, sortBy (flip compare) (candidates limit x))) [(x + 1)..listSize]
    in  case result of
            Nothing -> Just (x, y)
            Just (x', y':_) ->
                -- Use this solution (i.e., x' and y') to determine a new limit and recursively
                -- find the next potential solution
                let newLimit = pentagonalNumber x' - pentagonalNumber y'
                in  calcValue (x', y') newLimit

main = do
    let results = calcValue (1, 1) 1
        displayResults = case results of
                            Nothing -> "No result"
                            Just (x, y) ->
                                let diff = pentagonalNumber x - pentagonalNumber y
                                in  show diff
    putStrLn displayResults
